// Assumes polyglot.jar is in classpath
include "polyglot/ext/jl7/parse/jl7.ppg"

package gallifreyc.parse;

import gallifreyc.types.GallifreyTypeSystem;
import gallifreyc.ast.GallifreyNodeFactory;
import gallifreyc.ast.*;
import polyglot.parse.Name;
import polyglot.parse.VarDeclarator;

parser Grm extends polyglot.ext.jl7.parse.Grm {:
    public final GallifreyTypeSystem ts;
    public final GallifreyNodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (GallifreyTypeSystem) t;
        nf = (GallifreyNodeFactory) n;
    }
:};

terminal Token ALLOWS;
terminal Token BRANCH;
terminal Token CONTINGENT;
terminal Token DELETE;
terminal Token ENSURES;
terminal Token LOCAL;
terminal Token MATCH_RESTRICTION;
terminal Token MERGE;
terminal Token REQUIRES;
terminal Token RESTRICTION;
terminal Token SHARED;
terminal Token TEST;
terminal Token THREAD;
terminal Token TRANSITION;
terminal Token UNIQUE;
terminal Token WHEN;
terminal Token WHERE;
terminal Token WITH;
terminal Token ARROW;
terminal Token MOVE;

// Reference Qualifications (local, unique, shared)
non terminal PreCondition pre_condition_opt;
non terminal PostCondition post_condition_opt;

// Restrictions
non terminal TopLevelDecl restriction_declaration;
non terminal List<Id> restriction_variant;
non terminal RestrictionBody restriction_body;
non terminal List<Node> restriction_body_declarations_opt;
non terminal List<Node> restriction_body_declarations;
non terminal List<Node> restriction_body_declaration;
non terminal AllowsStmt allows_stmt;
non terminal MethodDecl test_declaration;
non terminal MethodDecl test_header;
non terminal RestrictionId restriction_id;
non terminal MatchBranch match_branch;
non terminal List<MatchBranch> match_branch_list;

// missing: where, merge, match, collection/next, thread, when, branch, peek, abort, commit

start with goal;

// Reference Qualifications (local, unique, shared)
extend class_or_interface_type ::=
      LOCAL:a class_or_interface_type:t
        {: 
            RefQualification r = parser.nf.LocalRef(parser.pos(a)); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
    | LOCAL:a LT IDENTIFIER:b GT class_or_interface_type:t
        {: 
            RefQualification r = parser.nf.LocalRef(parser.pos(a), b.getIdentifier()); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
    | UNIQUE:a class_or_interface_type:t
        {: 
            RefQualification r = parser.nf.UniqueRef(parser.pos(a)); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
    | SHARED:a LBRACK restriction_id:b RBRACK:c class_or_interface_type:t
        {: 
            RefQualification r = parser.nf.SharedRef(parser.pos(a, c), b); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
;

extend array_type ::=
      LOCAL:a array_type:t
        {: 
            RefQualification r = parser.nf.LocalRef(parser.pos(a)); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
    | LOCAL:a LT IDENTIFIER:b GT array_type:t
        {: 
            RefQualification r = parser.nf.LocalRef(parser.pos(a), b.getIdentifier()); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
    | UNIQUE:a array_type:t
        {: 
            RefQualification r = parser.nf.UniqueRef(parser.pos(a)); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
    | SHARED:a LBRACK restriction_id:b RBRACK:c array_type:t
        {: 
            RefQualification r = parser.nf.SharedRef(parser.pos(a, c), b); 
            RESULT = parser.nf.RefQualifiedTypeNode(parser.pos(a, t), r, t);
        :}
;

restriction_id ::=
	IDENTIFIER:a {: 
		RESULT = parser.nf.RestrictionId(
			parser.pos(a),
			null,
			parser.nf.Id(parser.pos(a), a.getIdentifier()),
			false); :}
	| MULT COLON COLON IDENTIFIER:a {: 
		RESULT = parser.nf.RestrictionId(
			parser.pos(a),
			null,
			parser.nf.Id(parser.pos(a), a.getIdentifier()),
			true); :}
	| IDENTIFIER:a COLON COLON IDENTIFIER:b {: 
		RESULT = parser.nf.RestrictionId(
			parser.pos(a),
			parser.nf.Id(parser.pos(a), a.getIdentifier()),
			parser.nf.Id(parser.pos(b), b.getIdentifier()),
			false); :}
;

// Pre/post conditions on method declarations in interfaces
override abstract_method_declaration ::=
    // MethodDecl
    method_header:a pre_condition_opt:b post_condition_opt:c SEMICOLON
		{: RESULT = parser.nf.MethodDecl(a.position(), a, b, c); :}
;

pre_condition_opt ::=
    // PreCondition
    {: RESULT = null; :}
    | REQUIRES:a expression:b
    {: RESULT = parser.nf.PreCondition(parser.pos(a, b), b); :}
;

post_condition_opt ::=
    // PostCondition
    {: RESULT = null; :}
    | ENSURES:a expression:b
    {: RESULT = parser.nf.PostCondition(parser.pos(a, b), b); :}
;

// Add Restrictions
override type_declarations ::=
    type_declaration:a {:
       List<TopLevelDecl> l = new LinkedList<>();
       if (a != null) l.add(a);
       RESULT = l; :}
 | restriction_declaration:a {:
       List<TopLevelDecl> l = new LinkedList<>();
       if (a != null) l.add(a);
       RESULT = l; :}
 |  type_declarations:a type_declaration:b {:
      RESULT = a;
      if (b != null) a.add(b); :}
 |  type_declarations:a restriction_declaration:b {:
      RESULT = a;
      if (b != null) a.add(b); :}
;

restriction_declaration ::=
    // RestrictionDecl
    RESTRICTION:a IDENTIFIER:b FOR class_or_interface_type:c restriction_body:d
	    {: RESULT = parser.nf.RestrictionDecl(parser.pos(a, d),
	                                          parser.nf.Id(parser.pos(b), b.getIdentifier()),
	                                          c, d); :}
	//Restriction Union Decl
   	| RESTRICTION:a IDENTIFIER:b EQ restriction_variant:u 
   		{: RESULT = parser.nf.RestrictionUnionDecl(
   				parser.pos(a, u), parser.nf.Id(parser.pos(b), b.getIdentifier()), u
   			);
   		 :}
;

restriction_variant ::=
	IDENTIFIER:a OR IDENTIFIER:b
		{: 
			List<Id> l = new ArrayList<>();
			l.add(parser.nf.Id(parser.pos(a), a.getIdentifier()));
			l.add(parser.nf.Id(parser.pos(b), b.getIdentifier()));
			RESULT = l; 
		:}
| restriction_variant:a OR IDENTIFIER:b
		{:
			a.add(parser.nf.Id(parser.pos(b), b.getIdentifier()));
			RESULT = a; 
		:}
;

restriction_body ::=
    // RestrictionBody
    LBRACE:a restriction_body_declarations_opt:b RBRACE:c
    	{: RESULT = parser.nf.RestrictionBody(parser.pos(a, c), b); :}
;

restriction_body_declarations_opt ::=
   	{: RESULT = new LinkedList<>(); :}
    | restriction_body_declarations:a
    {: RESULT = a; :}
;

restriction_body_declarations ::=
    restriction_body_declaration:a
	    {: RESULT = a; :}
	| restriction_body_declarations:a restriction_body_declaration:b
		{:
		 RESULT = a;
		 a.addAll(b);
		 :}
;

restriction_body_declaration ::=
    SEMICOLON
		{:
		 List<Node> l = new LinkedList<>();
		 RESULT = l; :}
    | allows_stmt:a SEMICOLON
	    {:
	     List<Node> l = new LinkedList<>();
	     l.add(a);
	     RESULT = l; :}
	| test_declaration:a
		{:
		 List<Node> l = new LinkedList<>();
		 l.add(a);
		 RESULT = l; :}
;

allows_stmt ::=
    // Node
    ALLOWS:a IDENTIFIER:b
    {: RESULT = parser.nf.AllowsStmt(parser.pos(a, b),
                                     parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
	| ALLOWS:a IDENTIFIER:b CONTINGENT IDENTIFIER:c
	{: RESULT = parser.nf.AllowsStmt(parser.pos(a, b),
	                                 parser.nf.Id(parser.pos(b), b.getIdentifier()),
	                                 parser.nf.Id(parser.pos(c), c.getIdentifier())); :}
;

// tests in restrictions

test_declaration ::=
    // MethodDecl
    test_header:a method_body:b
	{: RESULT = (MethodDecl) a.body(b); :}
;

test_header ::=
    // MethodDecl
    modifiers_or_annotations_opt:a TEST:b IDENTIFIER:c LPAREN
    formal_parameter_list_opt:d RPAREN:g throws_opt:f
    {: 
    	RESULT = parser.nf.MethodDecl(parser.pos(b, g, c), a,
                                     parser.nf.CanonicalTypeNode(parser.pos(b),
                                                                 parser.ts.Boolean()),
                                     parser.nf.Id(parser.pos(c), c.getIdentifier()),
                                     d, f, null, true); 
    :}
;

match_branch ::=
	OR type:a variable_declarator_id:b ARROW LBRACE statement:c RBRACE {:
		LocalDecl ld = parser.nf.LocalDecl(parser.pos(a,b), Flags.NONE, a, b.name()); 
		RESULT = parser.nf.MatchBranch(parser.pos(a, c), ld, c); 
	:}
;

match_branch_list ::=
	match_branch:a match_branch:b {:
		List<MatchBranch> br = new ArrayList<>();
		br.add(a);
		br.add(b);
		RESULT = br;
	:}
|   match_branch_list:a match_branch:b {:
		a.add(b);
		RESULT = a;
	:}
;

extend statement ::=
	TRANSITION LPAREN expression:a COMMA restriction_id:b RPAREN
	{: RESULT = parser.nf.Transition(parser.pos(a), a, b); :}
|   MATCH_RESTRICTION expression:a WITH match_branch_list:b 
	{: RESULT = parser.nf.MatchRestriction(parser.pos(a,b), a, b);:}
;

extend primary_no_new_array ::= 
	MOVE LPAREN expression:a RPAREN
	{: RESULT = parser.nf.Move(parser.pos(a), a); :}
;


